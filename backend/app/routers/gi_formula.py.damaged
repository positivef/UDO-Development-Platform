"""
GI Formula API Routes

API endpoints for Genius Insight Formula (5-stage insight generation)
"""

import logging
from typing import List, Optional

from fastapi import APIRouter, HTTPException, Path, Query

from ..models.gi_formula import (GIFormulaRequest, GIFormulaResult,
                                 GIInsightSummary)
from ..services.gi_formula_service import gi_formula_service

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v1/gi-formula", tags=["GI Formula"])


@router.post(
    "",
    response_model=GIFormulaResult,
    summary="Generate insight using GI Formula",
    description="""
    Generate actionable insight using 5-stage Genius Insight Formula:

    1. **Observation**: Extract key facts and constraints
    2. **Connection**: Find relationships between facts
    3. **Pattern**: Identify recurring patterns and trends
    4. **Synthesis**: Combine insights into actionable solution
    5. **Bias Check**: Validate against cognitive biases

    **Performance**: Target <30 seconds for complete analysis.

    **Features**:
    - Sequential MCP integration for structured reasoning
    - Automatic bias detection and mitigation
    - Obsidian knowledge base integration
    - 3-tier caching (Memory -> Redis -> SQLite)

    **Use Cases**:
    - Problem solving and decision making
    - Design analysis and optimization
    - Performance bottleneck identification
    - Security vulnerability analysis
    """,
    response_description="Complete GI Formula result with all 5 stages and bias check",
)
async def generate_insight(request: GIFormulaRequest) -> GIFormulaResult:
    """
    Generate insight using GI Formula

    Args:
        request: GI Formula request with problem and optional context

    Returns:
        Complete insight with 5-stage analysis and bias check

    Raises:
        HTTPException: If insight generation fails

    Example Request:
        ```json
        {
            "problem": "How can we reduce API response time by 50%?",
            "context": {
                "current_latency": "200ms",
                "target_latency": "100ms",
                "bottleneck": "database queries"
            },
            "project": "UDO-Development-Platform"
        }
        ```

    Example Response:
        ```json
        {
            "id": "gi-2025-11-20-abc123",
            "problem": "How can we reduce API response time by 50%?",
            "stages": {
                "observation": {...},
                "connection": {...},
                "pattern": {...},
                "synthesis": {...},
                "bias_check": {...}
            },
            "final_insight": "Implement connection pooling and Redis cache...",
            "bias_check": {
                "biases_detected": [],
                "mitigation_strategies": [],
                "confidence_score": 0.92
            },
            "total_duration_ms": 28500,
            "created_at": "2025-11-20T14:30:00",
            "obsidian_path": "[EMOJI]/2025-11-20/GI-Insight-API-Performance.md"
        }
        ```
    """
    try:
        logger.info(f"Generating insight for: {request.problem[:50]}...")

        result = await gi_formula_service.generate_insight(request)

        logger.info(
            f"Insight generated: {result.id} in {result.total_duration_ms}ms "
            f"(confidence: {result.bias_check.confidence_score:.2f})"
        )

        return result

    except ValueError as e:
        logger.error(f"Validation error: {e}")
        raise HTTPException(status_code=400, detail=f"Invalid request: {str(e)}")
    except RuntimeError as e:
        logger.error(f"Generation error: {e}")
        raise HTTPException(
            status_code=500, detail=f"Insight generation failed: {str(e)}"
        )
    except Exception as e:
        logger.error(f"Unexpected error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")


@router.get(
    "/{insight_id}",
    response_model=GIFormulaResult,
    summary="Get insight by ID",
    description="Retrieve a specific insight by its unique identifier",
    response_description="Complete insight result",
)
async def get_insight(
    insight_id: str = Path(
        ...,
        description="Unique insight ID (format: gi-YYYY-MM-DD-{hash})",
        example="gi-2025-11-20-abc123",
    )
) -> GIFormulaResult:
    """
    Get insight by ID

    Args:
        insight_id: Unique insight identifier

    Returns:
        Complete insight result

    Raises:
        HTTPException: If insight not found or retrieval fails
    """
    try:
        logger.info(f"Retrieving insight: {insight_id}")

        result = await gi_formula_service.get_insight(insight_id)

        if result is None:
            logger.warning(f"Insight not found: {insight_id}")
            raise HTTPException(
                status_code=404, detail=f"Insight not found: {insight_id}"
            )

        logger.info(f"Retrieved insight: {insight_id}")
        return result

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Retrieval error: {e}", exc_info=True)
        raise HTTPException(
            status_code=500, detail=f"Failed to retrieve insight: {str(e)}"
        )


@router.get(
    "",
    response_model=List[GIInsightSummary],
    summary="List recent insights",
    description="""
    List recent insights with pagination support.

    Results are sorted by creation time (newest first).
    """,
    response_description="List of insight summaries",
)
async def list_insights(
    project: Optional[str] = Query(
        None, description="Filter by project name", example="UDO-Development-Platform"
    ),
    limit: int = Query(10, ge=1, le=100, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Pagination offset"),
) -> List[GIInsightSummary]:
    """
    List recent insights

    Args:
        project: Optional project filter
        limit: Maximum results (1-100)
        offset: Pagination offset

    Returns:
        List of insight summaries

    Raises:
        HTTPException: If listing fails
    """
    try:
        logger.info(
            f"Listing insights (project={project}, limit={limit}, offset={offset})"
        )

        summaries = await gi_formula_service.list_insights(
            project=project, limit=limit, offset=offset
        )

        logger.info(f"Retrieved {len(summaries)} insights")
        return summaries

    except Exception as e:
        logger.error(f"Listing error: {e}", exc_info=True)
        raise HTTPException(
            status_code=500, detail=f"Failed to list insights: {str(e)}"
        )


@router.delete(
    "/{insight_id}",
    summary="Delete insight",
    description="Delete insight from cache",
    response_description="Deletion confirmation",
)
async def delete_insight(
    insight_id: str = Path(
        ..., description="Unique insight ID to delete", example="gi-2025-11-20-abc123"
    )
) -> dict:
    """
    Delete insight

    Args:
        insight_id: Unique insight identifier

    Returns:
        Deletion confirmation

    Raises:
        HTTPException: If deletion fails
    """
    try:
        logger.info(f"Deleting insight: {insight_id}")

        success = await gi_formula_service.delete_insight(insight_id)

        if not success:
            logger.warning(f"Failed to delete insight: {insight_id}")
            raise HTTPException(
                status_code=404,
                detail=f"Insight not found or deletion failed: {insight_id}",
            )

        logger.info(f"Deleted insight: {insight_id}")
        return {
            "message": f"Insight {insight_id} deleted successfully",
            "insight_id": insight_id,
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Deletion error: {e}", exc_info=True)
        raise HTTPException(
            status_code=500, detail=f"Failed to delete insight: {str(e)}"
        )


@router.get(
    "/health",
    summary="Health check",
    description="Check GI Formula service health",
    response_description="Service health status",
)
async def health_check() -> dict:
    """
    Health check endpoint

    Returns:
        Service health status
    """
    return {
        "status": "healthy",
        "service": "gi-formula",
        "version": "1.0.0",
        "features": {
            "sequential_mcp": gi_formula_service.sequential_mcp is not None,
            "obsidian_sync": gi_formula_service.obsidian_service is not None,
            "caching": gi_formula_service.cache_service is not None,
        },
    }
