#!/usr/bin/env python
"""
Obsidian Auto-Sync v2.0 - AI-Enhanced Development Log Generator

[EMOJI] Git commit [EMOJI] [EMOJI] Obsidian [EMOJI] [EMOJI].

Features (v2.0):
- [EMOJI] [EMOJI] [EMOJI] [EMOJI] (3+ [EMOJI], feat:/fix: [EMOJI])
- AI [EMOJI] [EMOJI] [EMOJI] ([EMOJI] [EMOJI], [EMOJI], [EMOJI] [EMOJI])
- [EMOJI] [EMOJI] [EMOJI] [EMOJI]
- YAML frontmatter [EMOJI] [EMOJI]

Usage:
  python scripts/obsidian_auto_sync.py --commit-hash <hash>
  python scripts/obsidian_auto_sync.py --commit-hash HEAD

Requirements:
- Git repository
- Obsidian vault configured in environment or default location

Author: System Automation Team
Date: 2025-12-14
Version: 2.0.0
"""

import argparse
import os
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Optional


class ObsidianAutoSync:
    """Obsidian [EMOJI] [EMOJI] [EMOJI]"""

    def __init__(self, repo_root: Path, vault_path: Optional[Path] = None):
        self.repo_root = repo_root
        self.vault_path = vault_path or self._get_default_vault_path()
        self.dev_log_dir = self.vault_path / "[EMOJI]"

    def _get_default_vault_path(self) -> Path:
        """[EMOJI] Obsidian vault [EMOJI] [EMOJI]"""
        # [EMOJI] [EMOJI] [EMOJI] [EMOJI]
        vault_env = os.getenv("OBSIDIAN_VAULT_PATH")
        if vault_env:
            return Path(vault_env)

        # Windows [EMOJI] [EMOJI]
        default_path = Path.home() / "Documents" / "Obsidian Vault"
        if default_path.exists():
            return default_path

        # Fallback
        return Path.home() / "obsidian-vault"

    def get_commit_info(self, commit_hash: str) -> Dict:
        """[EMOJI] [EMOJI] [EMOJI]"""
        try:
            # [EMOJI] [EMOJI]
            message = subprocess.check_output(
                ["git", "log", "-1", "--pretty=%B", commit_hash], cwd=self.repo_root, encoding="utf-8", errors="replace"
            ).strip()

            # [EMOJI] [EMOJI]
            commit_time = subprocess.check_output(
                ["git", "log", "-1", "--pretty=%ai", commit_hash], cwd=self.repo_root, encoding="utf-8", errors="replace"
            ).strip()

            # [EMOJI] [EMOJI] [EMOJI]
            files_changed = (
                subprocess.check_output(
                    ["git", "diff-tree", "--no-commit-id", "--name-only", "-r", commit_hash],
                    cwd=self.repo_root,
                    encoding="utf-8",
                    errors="replace",
                )
                .strip()
                .split("\n")
            )

            # [EMOJI]
            stats = subprocess.check_output(
                ["git", "log", "-1", "--stat", commit_hash], cwd=self.repo_root, encoding="utf-8", errors="replace"
            ).strip()

            # diff ([EMOJI] [EMOJI])
            diff = subprocess.check_output(
                ["git", "show", "--stat", commit_hash], cwd=self.repo_root, encoding="utf-8", errors="replace"
            ).strip()

            return {
                "hash": commit_hash,
                "message": message,
                "time": commit_time,
                "files_changed": [f for f in files_changed if f],
                "stats": stats,
                "diff": diff,
            }
        except subprocess.CalledProcessError as e:
            print(f"[ERROR] Failed to get commit info: {e}", file=sys.stderr)
            return {}

    def check_trigger_conditions(self, commit_info: Dict) -> Tuple[bool, str]:
        """[EMOJI] [EMOJI] [EMOJI]"""
        files_count = len(commit_info.get("files_changed", []))
        message = commit_info.get("message", "")

        # [EMOJI] 1: 3[EMOJI] [EMOJI] [EMOJI] [EMOJI]
        if files_count >= 3:
            return True, f"{files_count} files changed (>=3)"

        # [EMOJI] 2: feat:/fix:/docs: [EMOJI] [EMOJI] [EMOJI]
        trigger_patterns = [r"^feat:", r"^feature:", r"^fix:", r"^bug:", r"^docs:", r"^refactor:", r"^analyze:", r"^analysis:"]

        for pattern in trigger_patterns:
            if re.match(pattern, message, re.IGNORECASE):
                return True, f"Commit message matches: {pattern}"

        return False, f"No trigger (files: {files_count}, message: {message[:30]}...)"

    def generate_ai_insights(self, commit_info: Dict) -> Dict[str, List[str]]:
        """AI [EMOJI] [EMOJI] [EMOJI] ([EMOJI] [EMOJI])"""
        files = commit_info.get("files_changed", [])
        message = commit_info.get("message", "")
        diff = commit_info.get("diff", "")

        insights = {"learned": [], "challenges": [], "next_steps": []}

        # [EMOJI] [EMOJI] [EMOJI]
        if any("test" in f.lower() for f in files):
            insights["learned"].append("TDD [EMOJI] [EMOJI] [EMOJI] [EMOJI]")

        if "refactor" in message.lower():
            insights["learned"].append("[EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]")

        if any(keyword in message.lower() for keyword in ["performance", "optimize"]):
            insights["learned"].append("[EMOJI] [EMOJI] [EMOJI] [EMOJI]")

        if any(keyword in message.lower() for keyword in ["security", "auth"]):
            insights["learned"].append("[EMOJI] [EMOJI] [EMOJI] [EMOJI]")

        if len(files) >= 5:
            insights["learned"].append("[EMOJI] [EMOJI] [EMOJI] [EMOJI] ([EMOJI] [EMOJI] [EMOJI] [EMOJI])")

        # [EMOJI] [EMOJI]
        if "fix" in message.lower():
            insights["challenges"].append(f"[EMOJI] [EMOJI]: {message.split(':')[0]} -> [EMOJI] [EMOJI]")

        if len(files) > 10:
            insights["challenges"].append("[EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]")

        # [EMOJI] [EMOJI] (TODO [EMOJI] [EMOJI])
        todo_pattern = r"#\s*TODO:?\s*(.+)"
        todos_found = re.findall(todo_pattern, diff)
        if todos_found:
            insights["next_steps"].extend([f"TODO: {todo}" for todo in todos_found[:3]])

        # [EMOJI] [EMOJI] [EMOJI]
        if "feat" in message.lower():
            insights["next_steps"].append("[EMOJI] [EMOJI] [EMOJI]")

        if "fix" in message.lower():
            insights["next_steps"].append("[EMOJI] [EMOJI] [EMOJI] [EMOJI] [EMOJI]")

        return insights

    def categorize_work_type(self, commit_info: Dict) -> str:
        """[EMOJI] [EMOJI] [EMOJI]"""
        message = commit_info.get("message", "").lower()

        if any(kw in message for kw in ["feat", "feature", "add"]):
            return "feature"
        elif any(kw in message for kw in ["fix", "bug", "resolve"]):
            return "bugfix"
        elif "refactor" in message:
            return "refactor"
        elif any(kw in message for kw in ["docs", "document"]):
            return "documentation"
        elif "test" in message:
            return "testing"
        else:
            return "maintenance"

    def generate_frontmatter(self, commit_info: Dict, work_type: str) -> str:
        """YAML frontmatter [EMOJI]"""
        commit_time = datetime.fromisoformat(commit_info["time"].split("+")[0].strip())
        today = commit_time.strftime("%Y-%m-%d")
        time_str = commit_time.strftime("%H:%M")

        # [EMOJI] [EMOJI]
        files = commit_info.get("files_changed", [])
        tags = ["commit"]

        if any("test" in f.lower() for f in files):
            tags.append("testing")
        if any("docs" in f.lower() for f in files):
            tags.append("documentation")
        if work_type not in tags:
            tags.append(work_type)

        # Topic [EMOJI] ([EMOJI] [EMOJI] [EMOJI] [EMOJI])
        topic = commit_info.get("message", "").split("\n")[0]
        if ":" in topic:
            topic = topic.split(":", 1)[1].strip()

        frontmatter = f"""---
date: {today}
time: "{time_str}"
project: UDO-Development-Platform
topic: {topic}
commit: {commit_info['hash'][:7]}
type: {work_type}
tags: [{', '.join(tags)}]
files_changed: {len(files)}
---
"""
        return frontmatter

    def generate_dev_log(self, commit_info: Dict) -> str:
        """[EMOJI] [EMOJI] [EMOJI]"""
        work_type = self.categorize_work_type(commit_info)
        frontmatter = self.generate_frontmatter(commit_info, work_type)
        insights = self.generate_ai_insights(commit_info)

        # [EMOJI] [EMOJI]
        message = commit_info.get("message", "")
        message_lines = message.split("\n")
        title = message_lines[0]
        description = "\n".join(message_lines[1:]).strip() if len(message_lines) > 1 else ""

        # [EMOJI] [EMOJI] [EMOJI]
        files = commit_info.get("files_changed", [])
        files_by_category = {
            "Backend": [f for f in files if f.startswith("backend/")],
            "Frontend": [f for f in files if f.startswith("web-dashboard/")],
            "Docs": [f for f in files if f.startswith("docs/")],
            "Scripts": [f for f in files if f.startswith("scripts/")],
            "Tests": [f for f in files if "test" in f.lower()],
            "Other": [],
        }

        # Other [EMOJI] [EMOJI]
        categorized = sum(files_by_category.values(), [])
        files_by_category["Other"] = [f for f in files if f not in categorized]

        # [EMOJI] [EMOJI]
        content = frontmatter + f"\n# {title}\n\n"

        if description:
            content += f"{description}\n\n"

        content += "## [EMOJI] [EMOJI]\n\n"
        for category, category_files in files_by_category.items():
            if category_files:
                content += f"### {category} ({len(category_files)})\n"
                for file in category_files[:10]:  # [EMOJI] 10[EMOJI]
                    content += f"- `{file}`\n"
                if len(category_files) > 10:
                    content += f"- ... and {len(category_files) - 10} more\n"
                content += "\n"

        # AI [EMOJI]
        if insights["learned"]:
            content += "## [EMOJI] [EMOJI] [EMOJI]\n\n"
            for item in insights["learned"]:
                content += f"- {item}\n"
            content += "\n"

        if insights["challenges"]:
            content += "## [EMOJI] [EMOJI]\n\n"
            for item in insights["challenges"]:
                content += f"- {item}\n"
            content += "\n"

        if insights["next_steps"]:
            content += "## [EMOJI] [EMOJI] [EMOJI]\n\n"
            for item in insights["next_steps"]:
                content += f"- {item}\n"
            content += "\n"

        # [EMOJI] [EMOJI]
        content += "## [EMOJI] [EMOJI]\n\n"
        content += f"```\n{commit_info.get('stats', '')}\n```\n\n"

        content += f"**[EMOJI] [EMOJI]**: `{commit_info['hash'][:7]}`  \n"
        content += f"**[EMOJI] [EMOJI]**: {commit_info['time']}  \n"
        content += f"**[EMOJI] [EMOJI]**: Obsidian Auto-Sync v2.0  \n"

        return content

    def sync(self, commit_hash: str) -> bool:
        """Obsidian [EMOJI] [EMOJI]"""
        try:
            # 1. [EMOJI] [EMOJI] [EMOJI]
            commit_info = self.get_commit_info(commit_hash)
            if not commit_info:
                print("[ERROR] Failed to get commit info", file=sys.stderr)
                return False

            # 2. [EMOJI] [EMOJI] [EMOJI]
            triggered, reason = self.check_trigger_conditions(commit_info)
            if not triggered:
                print(f"[SKIP] Trigger condition not met: {reason}")
                return True  # [EMOJI] [EMOJI]

            print(f"[TRIGGER] {reason}")

            # 3. [EMOJI] [EMOJI]
            dev_log_content = self.generate_dev_log(commit_info)

            # 4. Obsidian[EMOJI] [EMOJI]
            commit_time = datetime.fromisoformat(commit_info["time"].split("+")[0].strip())
            date_folder = commit_time.strftime("%Y-%m-%d")
            topic = commit_info.get("message", "").split("\n")[0].replace(":", "-").replace("/", "-")[:50]
            filename = f"{topic}.md"

            # [EMOJI] [EMOJI] [EMOJI]
            date_dir = self.dev_log_dir / date_folder
            date_dir.mkdir(parents=True, exist_ok=True)

            # [EMOJI] [EMOJI]
            file_path = date_dir / filename
            file_path.write_text(dev_log_content, encoding="utf-8")

            print(f"[OK] Obsidian dev log created: {date_folder}/{filename}")
            return True

        except Exception as e:
            print(f"[ERROR] Sync failed: {e}", file=sys.stderr)
            import traceback

            traceback.print_exc()
            return False


def main():
    """[EMOJI] [EMOJI]"""
    parser = argparse.ArgumentParser(description="Obsidian Auto-Sync v2.0")
    parser.add_argument("--commit-hash", default="HEAD", help="Commit hash to sync")
    parser.add_argument("--vault", help="Obsidian vault path (optional)")
    args = parser.parse_args()

    # Repo root [EMOJI]
    repo_root = Path(__file__).resolve().parents[1]

    # Vault [EMOJI]
    vault_path = Path(args.vault) if args.vault else None

    # [EMOJI] [EMOJI]
    syncer = ObsidianAutoSync(repo_root, vault_path)
    success = syncer.sync(args.commit_hash)

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
